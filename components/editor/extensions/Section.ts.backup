import { Node, mergeAttributes } from '@tiptap/core';

export interface SectionOptions {
  HTMLAttributes: Record<string, string>;
}

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    section: {
      setSection: () => ReturnType;
      toggleSection: () => ReturnType;
    };
  }
}

export const Section = Node.create<SectionOptions>({
  name: 'section',

  group: 'block',

  content: 'block+',

  defining: true,

  isolating: true,

  addOptions() {
    return {
      HTMLAttributes: {},
    };
  },

  addAttributes() {
    return {
      title: {
        default: 'ìƒˆ ì„¹ì…˜',
        parseHTML: element => element.getAttribute('data-section-title'),
        renderHTML: attributes => {
          return {
            'data-section-title': attributes.title,
          };
        },
      },
      collapsed: {
        default: false,
        parseHTML: element => element.getAttribute('data-collapsed') === 'true',
        renderHTML: attributes => {
          return {
            'data-collapsed': String(attributes.collapsed),
          };
        },
      },
    };
  },

  parseHTML() {
    return [
      {
        tag: 'div[data-section]',
      },
    ];
  },

  renderHTML({ HTMLAttributes }) {
    return [
      'div',
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        'data-section': 'true',
        class: 'editor-section',
      }),
      [
        'div',
        {
          class: 'editor-section-header',
          contenteditable: 'false',
        },
        [
          'div',
          {
            class: 'editor-section-title-wrapper',
          },
          [
            'span',
            {
              class: 'editor-section-icon',
            },
            'ðŸ“‚',
          ],
          [
            'input',
            {
              class: 'editor-section-title',
              type: 'text',
              value: HTMLAttributes.title || 'ìƒˆ ì„¹ì…˜',
              placeholder: 'ì„¹ì…˜ ì œëª©ì„ ìž…ë ¥í•˜ì„¸ìš”',
            },
          ],
        ],
      ],
      [
        'div',
        {
          class: 'editor-section-content',
        },
        0,
      ],
    ];
  },

  addNodeView() {
    return ({ node, getPos, editor }) => {
      const dom = document.createElement('div');
      dom.setAttribute('data-section', 'true');
      dom.className = 'editor-section';
      dom.setAttribute('data-section-title', node.attrs.title);

      const header = document.createElement('div');
      header.className = 'editor-section-header';
      header.contentEditable = 'false';

      const titleWrapper = document.createElement('div');
      titleWrapper.className = 'editor-section-title-wrapper';

      const icon = document.createElement('span');
      icon.className = 'editor-section-icon';
      icon.textContent = 'ðŸ“‚';

      const input = document.createElement('input');
      input.className = 'editor-section-title';
      input.type = 'text';
      input.value = node.attrs.title || 'ìƒˆ ì„¹ì…˜';
      input.placeholder = 'ì„¹ì…˜ ì œëª©ì„ ìž…ë ¥í•˜ì„¸ìš”';

      // input ì´ë²¤íŠ¸ ì²˜ë¦¬: ì œëª© ì—…ë°ì´íŠ¸
      input.addEventListener('input', (e) => {
        const target = e.target as HTMLInputElement;
        if (typeof getPos === 'function') {
          const pos = getPos();
          if (pos !== undefined) {
            editor.view.dispatch(
              editor.view.state.tr.setNodeMarkup(pos, undefined, {
                ...node.attrs,
                title: target.value,
              })
            );
          }
        }
      });

      // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€: ë°±ìŠ¤íŽ˜ì´ìŠ¤, ì‚­ì œ ë“±ì´ ì—ë””í„°ë¡œ ì „ë‹¬ë˜ì§€ ì•Šë„ë¡
      input.addEventListener('keydown', (e) => {
        e.stopPropagation();
      });

      // í¬ì»¤ìŠ¤ ì´ë²¤íŠ¸ ì²˜ë¦¬
      input.addEventListener('mousedown', (e) => {
        e.stopPropagation();
      });

      titleWrapper.appendChild(icon);
      titleWrapper.appendChild(input);
      header.appendChild(titleWrapper);

      const content = document.createElement('div');
      content.className = 'editor-section-content';

      dom.appendChild(header);
      dom.appendChild(content);

      return {
        dom,
        contentDOM: content,
        update: (updatedNode) => {
          if (updatedNode.type.name !== 'section') return false;
          // inputì´ focusë˜ì–´ ìžˆì§€ ì•Šì„ ë•Œë§Œ value ì—…ë°ì´íŠ¸ (ì‚¬ìš©ìž ìž…ë ¥ ì¤‘ì—ëŠ” ë®ì–´ì“°ì§€ ì•ŠìŒ)
          if (document.activeElement !== input) {
            input.value = updatedNode.attrs.title;
          }
          dom.setAttribute('data-section-title', updatedNode.attrs.title);
          return true;
        },
      };
    };
  },

  addCommands() {
    return {
      setSection:
        () =>
        ({ commands, state }) => {
          // í˜„ìž¬ ì»¤ì„œê°€ ì„¹ì…˜ ì•ˆì— ìžˆëŠ”ì§€ í™•ì¸
          const { $from } = state.selection;
          let isInSection = false;

          // ë¶€ëª¨ ë…¸ë“œë“¤ì„ ìˆœíšŒí•˜ë©´ì„œ ì„¹ì…˜ì´ ìžˆëŠ”ì§€ í™•ì¸
          for (let depth = $from.depth; depth > 0; depth--) {
            if ($from.node(depth).type.name === 'section') {
              isInSection = true;
              break;
            }
          }

          // ì„¹ì…˜ ì•ˆì— ìžˆìœ¼ë©´ ì„¹ì…˜ ìƒì„±í•˜ì§€ ì•ŠìŒ (ì¤‘ì²© ë°©ì§€)
          if (isInSection) {
            return false;
          }

          return commands.wrapIn(this.name, { title: 'ìƒˆ ì„¹ì…˜' });
        },
      toggleSection:
        () =>
        ({ commands }) => {
          return commands.toggleWrap(this.name);
        },
    };
  },
});
